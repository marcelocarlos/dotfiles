#
# Based on https://github.com/pahen/dotfiles/blob/master/.completions
#

# Add case-insensitive `killall` tab completion of running apps
_complete_running_processes ()
{
    local LC_ALL='C'
    local IFS=$'\n'
    local cur=${COMP_WORDS[COMP_CWORD]}

    COMPREPLY=()

    # do not attempt completion if we're specifying an option
    [[ "$cur" == -* ]] && return 0

    # Escape dots in paths for grep
    cur=${cur//\./\\\.}

    COMPREPLY=( $(ps axc | tail -n +2 | awk '{ print $5 }' | sort -u | grep -v "^[\-\(]" | grep -i "^$cur") )
}
complete -o bashdefault -o default -o nospace -F _complete_running_processes killall

# Add case-insensitive `kill` tab completion of running apps
_complete_running_processes_pids ()
{
    local re
    local LC_ALL='C'
    local IFS=$'\n'
    local cur=${COMP_WORDS[COMP_CWORD]}

    COMPREPLY=()

    # do not attempt completion if we're specifying an option
    [[ "$cur" == -* ]] && return 0

    # Escape dots in paths for grep
    cur=${cur//\./\\\.}

    if [[ $cur != *[!0-9]* ]]; then
        # search by PID
        re="^$cur"
    else
        # search by process name
        re="^[0-9]+ # $cur[^$]"
    fi

    COMPREPLY=( $(ps axc | tail -n +2 | awk '{print $1 " # " $5}' | sort -u | grep -v "^[\-\(]" | egrep -i "$re") )
}
complete -o bashdefault -o default -o nospace -F _complete_running_processes_pids kill

_completemarks() {
  local curw=${COMP_WORDS[COMP_CWORD]}
  local wordlist=$(find $MARKPATH -type l -exec basename {} \;)
  COMPREPLY=($(compgen -W '${wordlist[@]}' -- "$curw"))
  return 0
}

complete -F _completemarks jump j unmark



# enable autocompletion for the alias (if the command exists)
# TODO: MOVE CHEATSHEETS COMPLETION HERE
command -v cheatsheets.sh >/dev/null && complete -F _cheatsheets_autocomplete cs

source <(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.
