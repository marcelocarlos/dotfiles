# Created by Marcelo C. Carlos
# Modified setup from https://github.com/mathiasbynens/dotfiles
#
# This version includes information about svn and git status when you are in a version controlled folder
#

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM=xterm-256color
fi

tput sgr0

  #BOLD="\[\033[1m\]"
  #RED="\[\033[1;31m\]"
  #GREEN="\[\e[32;1m\]"
  #BLUE="\[\e[34;1m\]"
  #OFF="\[\033[m\]"

BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
TURQUOISE="\[\033[00;36m\]"
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)

BOLD=$(tput bold)
RESET=$(tput sgr0)

export BLACK
export RED
export GREEN
export YELLOW
export BLUE
export MAGENTA
export CYAN
export WHITE
export BOLD
export TURQUOISE
export RESET

# function parse_git_dirty() {
# 	if [ "$(uname)" == "Darwin" ]; then
#     	[[ $(git status 2> /dev/null | tail -n1) != "nothing to commit, working directory clean" ]] && echo "*"
# 	elif [ "$(expr substr $(uname -s) 1 5)" == "Linux" ]; then
# 		[[ $(git status 2> /dev/null | tail -n1) != "nothing to commit (working directory clean)" ]] && echo "*"
# 	fi
# }

# function parse_git_branch() {
# 	git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/" | awk '{print "  [git: "$1"]" }'
# }

function parse_svn_branch() {
	parse_svn_url | sed -e 's#^'"$(parse_svn_repository_root)"'##g' -e "s/$/$(parse_svn_dirty)/" | awk '{print "  [svn: "$1"] " }'
}

function parse_svn_url() {
  svn info 2>/dev/null | sed -ne 's#^URL: ##p'
}

function parse_svn_repository_root() {
  svn info 2>/dev/null | sed -ne 's#^Repository Root: ##p'
}

function parse_svn_dirty() {
	[[ $(svn status 2> /dev/null | tail -n1) != "" ]] && echo "*"
}

# modified version of the one in http://joefleming.net/posts/git-info-in-your-bash-prompt/
function parse_git_info {
    git rev-parse --git-dir > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        git_status="$(git status 2> /dev/null)"

        branch_pattern="On branch ([^${IFS}]*)"
        detached_branch_pattern="Not currently on any branch"
        remote_pattern="Your branch is (.*) of ([^${IFS}]*) by ([^${IFS}]*)"
        diverge_pattern="Your branch and (.*) have diverged"
        diverge_pattern_count="and have ([^${IFS}]*) and ([^${IFS}]*) different commits"
        untracked_pattern="Untracked files:"
        new_pattern="new file:"
        not_staged_pattern="Changes not staged for commit"
        staged_pattern="Changes to be committed"

        #files not staged for commit
        if [[ ${git_status}} =~ ${not_staged_pattern} ]] || [[ ${git_status} =~ ${untracked_pattern} ]] || [[ ${git_status} =~ ${staged_pattern} ]] || [[ ${git_status} =~ ${new_pattern} ]]; then
            state=" *"
            #remote="✖"
            #remote=" +"
        fi
        # add an else if or two here if you want to get more specific
        # show if we're ahead or behind HEAD
        if [[ ${git_status} =~ ${remote_pattern} ]]; then
            if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
                remote=" ▲(${BASH_REMATCH[3]})" # ▴ ↑
            else
                remote=" ▼(${BASH_REMATCH[3]})" # ▾ ↓
            fi
        fi

        #diverged branch
        #if [[ ${git_status} =~ ${diverge_pattern} ]]; then
        if [[ ${git_status} =~ ${diverge_pattern_count} ]]; then
            	remote=" (${BASH_REMATCH[1]})ⵖ(${BASH_REMATCH[2]})" # ↕ ߌ 𐌖
        fi
        #branch name
        if [[ ${git_status} =~ ${branch_pattern} ]]; then
            branch=${BASH_REMATCH[1]}
        #detached branch
        elif [[ ${git_status} =~ ${detached_branch_pattern} ]]; then
            branch="NO BRANCH"
        fi

        echo "[git: ${branch}${remote}${state}]"
    fi
    return
}

function parse_user {
	if [ "$(id -u)" == "0" ]; then
		echo "\[${BOLD}${RED}\]\u\[$RESET\]"
	else
		echo "\[${BOLD}${TURQUOISE}\]\u\[$RESET\]"
	fi
}

PS1="\[$BOLD\]\[$GREEN\]\w\[$BLACK\] at $(parse_user)\[$BLACK\]@\[$BOLD\]\[$BLUE\]\h \[$RESET\]\[$BLACK\]\[$YELLOW\]\$(parse_git_info)\$(parse_svn_branch)\[$BLACK\]\n\$ \[$RESET\]"

# PS1="\[$BOLD\]\[$GREEN\]\w\[$BLACK\] at \[${BOLD}${BLUE}\]\u\[$RESET\]\[$BLACK\]@\[$BOLD\]\[$CYAN\]\h \[$RESET\]\[$BLACK\]\[$YELLOW\]\$(parse_git_branch)\$(parse_svn_branch)\[$BLACK\]\n\$ \[$RESET\]"

# PS1="\[${BOLD}${RED}\]\u \[$RESET\]\[$BLACK\]at \[$BOLD\]\[$CYAN\]\h \[$RESET\]\[$BLACK\]in \[$BOLD\]\[$GREEN\]\w\[$BLACK\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\$([[ -n \$(svn info 2> /dev/null) ]] && echo \" on \")\[$YELLOW\]\$(parse_git_branch)\$(parse_svn_branch)\[$BLACK\]\n\$ \[$RESET\]"
